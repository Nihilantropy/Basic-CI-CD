pipeline {
    /* Use the custom Docker agent from agent folder */
    agent {
        dockerfile {
            filename 'Dockerfile'
            dir 'agent'
            args '--network=host -v /var/run/docker.sock:/var/run/docker.sock'
        }
    }

	options {
		gitLabConnection('gitlab-local')
	}

    parameters {
        // Core execution controls - these will only be used for manual builds
        booleanParam(name: 'RUN_TESTS', defaultValue: true, description: 'Run the test stage')
        booleanParam(name: 'RUN_RUFF_CHECK', defaultValue: false, description: 'Run the Ruff code quality check')
        booleanParam(name: 'RUN_BANDIT_CHECK', defaultValue: false, description: 'Run the Bandit security check')
        booleanParam(name: 'UPDATE_VERSION', defaultValue: false, description: 'Update version information')
        booleanParam(name: 'BUILD_EXECUTABLE', defaultValue: false, description: 'Build the executable')
        booleanParam(name: 'ARCHIVE_EXECUTABLE', defaultValue: false, description: 'Archive the executable')
        booleanParam(name: 'UPLOAD_TO_NEXUS', defaultValue: false, description: 'Upload artifacts to Nexus')
        booleanParam(name: 'PUSH_GIT_CHANGES', defaultValue: false, description: 'Push changes and create tag')
        
        // Integration controls
        booleanParam(name: 'ENABLE_GITLAB_STATUS', defaultValue: false, description: 'Update GitLab commit status')
        booleanParam(name: 'ENABLE_TELEGRAM', defaultValue: false, description: 'Send Telegram notifications')
    }

    environment {
        // Nexus configuration
        NEXUS_VERSION = "nexus3"
        NEXUS_PROTOCOL = "http"
        NEXUS_URL = "nexus:8081"
        NEXUS_REPO = "my-artifacts"
        NEXUS_CREDENTIALS_ID = "bb41509b-d0cc-4f65-94a4-755c22441930"
        GROUP_ID = "WmcA"
        ARTIFACT_ID = "flask-app"
        
        // Git configuration for pushing changes
        GIT_CREDENTIALS_ID = "gitlab-credentials"
        
        // Timestamp to use throughout the pipeline - in format yearmonthday hour minutes seconds
        TIMESTAMP = sh(script: 'date +%Y%m%d%H%M%S', returnStdout: true).trim()
        
        // The repository URL base (will be used with credentials)
        GIT_REPO_URL = "http://gitlab/pipeline-project-group/app-flask.git"
    }

    stages {
		stage('Checkout') {
			steps {
                checkout scm

                scmSkip(deleteBuild: true, skipPattern:'.*\\[ci skip\\].*')
			}
		}

        stage('Load Configuration') {
            steps {
                script {
                    echo "Loading configuration from jenkins-config.yml if available..."
                    
                    // Initialize global variables for stage control
                    env.DO_RUN_TESTS = params.RUN_TESTS.toString()
                    env.DO_RUN_RUFF_CHECK = params.RUN_RUFF_CHECK.toString()
                    env.DO_RUN_BANDIT_CHECK = params.RUN_BANDIT_CHECK.toString()
                    env.DO_UPDATE_VERSION = params.UPDATE_VERSION.toString()
                    env.DO_BUILD_EXECUTABLE = params.BUILD_EXECUTABLE.toString()
                    env.DO_ARCHIVE_EXECUTABLE = params.ARCHIVE_EXECUTABLE.toString()
                    env.DO_UPLOAD_TO_NEXUS = params.UPLOAD_TO_NEXUS.toString()
                    env.DO_PUSH_GIT_CHANGES = params.PUSH_GIT_CHANGES.toString()
                    env.DO_ENABLE_GITLAB_STATUS = params.ENABLE_GITLAB_STATUS.toString()
                    env.DO_ENABLE_TELEGRAM = params.ENABLE_TELEGRAM.toString()
                    
                    // Try to load the configuration file
                    try {
                        if (fileExists('jenkins-config.yml')) {
                            echo "Found jenkins-config.yml file, loading configuration..."
                            def config = readYaml(file: 'jenkins-config.yml')
                            echo "Config loaded: ${config}"
                            
                            // Override global variables with values from config file
                            if (config.runTests != null) env.DO_RUN_TESTS = config.runTests.toString()
                            if (config.runRuffCheck != null) env.DO_RUN_RUFF_CHECK = config.runRuffCheck.toString()
                            if (config.runBanditCheck != null) env.DO_RUN_BANDIT_CHECK = config.runBanditCheck.toString()
                            if (config.updateVersion != null) env.DO_UPDATE_VERSION = config.updateVersion.toString()
                            if (config.buildExecutable != null) env.DO_BUILD_EXECUTABLE = config.buildExecutable.toString()
                            if (config.archiveExecutable != null) env.DO_ARCHIVE_EXECUTABLE = config.archiveExecutable.toString()
                            if (config.uploadToNexus != null) env.DO_UPLOAD_TO_NEXUS = config.uploadToNexus.toString()
                            if (config.pushGitChanges != null) env.DO_PUSH_GIT_CHANGES = config.pushGitChanges.toString()
                            if (config.enableGitlabStatus != null) env.DO_ENABLE_GITLAB_STATUS = config.enableGitlabStatus.toString()
                            if (config.enableTelegram != null) env.DO_ENABLE_TELEGRAM = config.enableTelegram.toString()
                            
                            echo "Configuration values set from config file"
                        } else {
                            echo "No jenkins-config.yml file found, using parameter values"
                        }
                    } catch (Exception e) {
                        echo "Error loading config file: ${e.getMessage()}"
                        echo "Using parameter values instead"
                    }
                }
            }
        }
        
        stage('Pipeline Start') {
            steps {
                script {
                    // Update GitLab status if enabled
                    updateGitLabStatus('pipeline', 'running')
                    
                    // Send notification
                    notify("üöÄ Pipeline started for ${env.JOB_NAME} #${env.BUILD_NUMBER} at ${TIMESTAMP}")
                    
                    // Print selected stages for clarity
                    echo "Running with the following configuration:"
                    echo "Tests: ${DO_RUN_TESTS}"
                    echo "Ruff Check: ${DO_RUN_RUFF_CHECK}"
                    echo "Bandit Check: ${DO_RUN_BANDIT_CHECK}"
                    echo "Update Version: ${DO_UPDATE_VERSION}"
                    echo "Build Executable: ${DO_BUILD_EXECUTABLE}"
                    echo "Archive Executable: ${DO_ARCHIVE_EXECUTABLE}"
                    echo "Upload to Nexus: ${DO_UPLOAD_TO_NEXUS}"
                    echo "Push Git Changes: ${DO_PUSH_GIT_CHANGES}"
                    echo "GitLab Status Updates: ${DO_ENABLE_GITLAB_STATUS}"
                    echo "Telegram Notifications: ${DO_ENABLE_TELEGRAM}"
                }
            }
        }
        
        stage('Run Tests') {
            when {
                expression { 
                    return env.DO_RUN_TESTS == 'true' 
                }
            }
            steps {
                runStage('tests', 'Running tests with pytest... üß™') {
                    sh '''
                    . /app/venv/bin/activate
                    python -m pytest srcs/tests --maxfail=1 --disable-warnings -v
                    '''
                }
            }
        }

        stage('Code Quality Check - Ruff') {
            when {
                expression { 
                    return env.DO_RUN_RUFF_CHECK == 'true' 
                }
            }
            steps {
                runStage('ruff-check', 'Running Ruff code quality check... üîç') {
                    sh '''
                    . /app/venv/bin/activate
                    python -m ruff check . --select all
                    '''
                }
            }
        }

        stage('Security Check - Bandit') {
            when {
                expression { 
                    return env.DO_RUN_BANDIT_CHECK == 'true' 
                }
            }
            steps {
                runStage('bandit', 'Running Bandit security check... üîí') {
                    sh '''
                    . /app/venv/bin/activate
                    python -m bandit -r . -ll -iii
                    '''
                }
            }
        }

        stage('Update Version Information') {
            when {
                expression { 
                    return env.DO_UPDATE_VERSION == 'true' 
                }
            }
            steps {
                runStage('version-update', 'Updating version information... üìù') {
                    // Update version.py with the timestamp
                    sh "sed -i \"s/\\\${PLACEHOLDER_VERSION}/${env.TIMESTAMP}/g\" srcs/main/version.py"
                    
                    // Verify version.py was updated correctly
                    sh "cat srcs/main/version.py"
                    
                    // Also update version.info file to keep it in sync
                    sh "echo ${env.TIMESTAMP} > version.info"
                }
            }
        }

        stage('Build Executable') {
            when {
                expression { 
                    return env.DO_BUILD_EXECUTABLE == 'true' 
                }
            }
            steps {
                runStage('build', 'Building executable using PyInstaller... üîß') {
                    // Run PyInstaller directly using the binary instead of the module
                    sh '''
                    . /app/venv/bin/activate
                    /app/venv/bin/pyinstaller --onefile srcs/main/app.py --name flask-app
                    '''
                }
            }
        }

        stage('Archive Executable') {
            when {
                expression {
                    return env.DO_ARCHIVE_EXECUTABLE == 'true' && env.DO_BUILD_EXECUTABLE == 'true' 
                }
            }
            steps {
                runStage('archive', 'Archiving the built executable... üì¶') {
                    archiveArtifacts artifacts: 'dist/flask-app', fingerprint: true
                }
            }
        }

        stage('Upload to Nexus') {
            when {
                expression { 
                    return env.DO_UPLOAD_TO_NEXUS == 'true' && env.DO_BUILD_EXECUTABLE == 'true' 
                }
            }
            steps {
                runStage('nexus-upload', 'Uploading artifacts to Nexus... üöÄ') {
                    // Upload with "latest" tag
                    nexusArtifactUploader(
                        nexusVersion: env.NEXUS_VERSION,
                        protocol: env.NEXUS_PROTOCOL,
                        nexusUrl: env.NEXUS_URL,
                        groupId: env.GROUP_ID,
                        version: 'latest',
                        repository: env.NEXUS_REPO,
                        credentialsId: env.NEXUS_CREDENTIALS_ID,
                        artifacts: [
                            [
                                artifactId: env.ARTIFACT_ID,
                                type: 'bin',
                                file: 'dist/flask-app',
                                classifier: ''
                            ]
                        ]
                    )
                    
                    // Upload with timestamp tag
                    nexusArtifactUploader(
                        nexusVersion: env.NEXUS_VERSION,
                        protocol: env.NEXUS_PROTOCOL,
                        nexusUrl: env.NEXUS_URL,
                        groupId: env.GROUP_ID,
                        version: env.TIMESTAMP,
                        repository: env.NEXUS_REPO,
                        credentialsId: env.NEXUS_CREDENTIALS_ID,
                        artifacts: [
                            [
                                artifactId: env.ARTIFACT_ID,
                                type: 'bin',
                                file: 'dist/flask-app',
                                classifier: ''
                            ]
                        ]
                    )
                }
            }
        }

        stage('Push Changes & Create Tag') {
            when {
                expression { 
                    return env.DO_PUSH_GIT_CHANGES == 'true' && env.DO_UPDATE_VERSION == 'true' 
                }
            }
            steps {
                runStage('git-push', 'Pushing version updates to repository... üì§') {
                    withCredentials([usernamePassword(credentialsId: env.GIT_CREDENTIALS_ID, 
                                                     usernameVariable: 'GIT_USERNAME', 
                                                     passwordVariable: 'GIT_PASSWORD')]) {              
						sh '''
							git config user.email "claudio0017.work@gmail.com"
							git config user.name "crea"
						'''
                        
                        // Add, commit, and push version-related changes
                        sh "git add version.info"
                        sh "git commit -m 'Update version to ${env.TIMESTAMP} [ci skip]'"


						sh '''
							# Push to the same repository as your remote origin
							git push http://$GIT_USERNAME:$GIT_PASSWORD@gitlab/pipeline-project-group/pipeline-project.git HEAD:refs/heads/$GIT_BRANCH
							echo timestamp is: $TIMESTAMP
							# Create tag with proper syntax - note the tag name $TIMESTAMP here
							git tag -a $TIMESTAMP -m "Release $TIMESTAMP"
							
							# Push the tag
							git push http://$GIT_USERNAME:$GIT_PASSWORD@gitlab/pipeline-project-group/pipeline-project.git refs/tags/$TIMESTAMP
						'''


						// TODO push on the main branch the new app Release (entire folder) with the timestamp version

                        
                        // Notify about successful tag creation
                        notify("Jenkins: Tag ${env.TIMESTAMP} created and pushed")
                    }
                }
            }
        }
    }
    
    post {
        success {
            script {
                updateGitLabStatus('pipeline', 'success')
                notify("üéâ Pipeline succeeded for ${env.JOB_NAME} #${env.BUILD_NUMBER}! All stages completed successfully.")
            }
        }
        failure {
            script {
                updateGitLabStatus('pipeline', 'failed')
                notify("‚ùå Pipeline failed for ${env.JOB_NAME} #${env.BUILD_NUMBER}. Check Jenkins for details.")
            }
        }
    }
}

// Helper function to update GitLab status
def updateGitLabStatus(String name, String state) {
    if (env.DO_ENABLE_GITLAB_STATUS == 'true') {
        updateGitlabCommitStatus name: name, state: state
    } else {
        echo "GitLab status updates disabled. Would have set ${name} to ${state}."
    }
}

// Helper function to send notifications
def notify(String message) {
    echo message
    if (env.DO_ENABLE_TELEGRAM == 'true') {
        sendTelegramMessage(message)
    } else {
        echo "Telegram notifications disabled. Would have sent: ${message}"
    }
}

// Helper function to execute a stage with proper error handling
def runStage(String stageName, String notificationMessage, Closure stageBody) {
    updateGitLabStatus(stageName, 'running')
    try {
        notify("Jenkins: ${notificationMessage}")
        stageBody()
        updateGitLabStatus(stageName, 'success')
        notify("Jenkins: ${stageName} completed successfully ‚úÖ")
    } catch (Exception e) {
        updateGitLabStatus(stageName, 'failed')
        def errorLog = e.getMessage()
        notify("Jenkins: ${stageName} failed ‚ùå\n")
        error "${stageName} failed. Pipeline interrupted."
    }
}

// Send message to Telegram
def sendTelegramMessage(String message) {
    // URL encode the message
    def encodedMessage = URLEncoder.encode(message, "UTF-8")
    
    withCredentials([
        string(credentialsId: 'telegram-token', variable: 'TOKEN'),
        string(credentialsId: 'telegram-chat-id', variable: 'CHAT_ID')
    ]) {
        sh '''
            curl -s -X POST https://api.telegram.org/bot${TOKEN}/sendMessage \
            -d chat_id=${CHAT_ID} \
            -d text="''' + encodedMessage + '''"
        '''
    }
}