pipeline {
    /* Use the custom Docker agent from agent folder */
    agent {
        dockerfile {
            filename 'Dockerfile'
            dir 'agent'
            args '--network=host -v /var/run/docker.sock:/var/run/docker.sock'
        }
    }

    options {
        gitLabConnection('gitlab-local')
    }

    parameters {
        // Core execution controls - these will only be used for manual builds
        booleanParam(name: 'RUN_TESTS', defaultValue: true, description: 'Run the test stage')
        booleanParam(name: 'RUN_RUFF_CHECK', defaultValue: false, description: 'Run the Ruff code quality check')
        booleanParam(name: 'RUN_BANDIT_CHECK', defaultValue: false, description: 'Run the Bandit security check')
        booleanParam(name: 'UPDATE_VERSION', defaultValue: false, description: 'Update version information')
        booleanParam(name: 'BUILD_EXECUTABLE', defaultValue: false, description: 'Build the executable')
        booleanParam(name: 'ARCHIVE_EXECUTABLE', defaultValue: false, description: 'Archive the executable')
        booleanParam(name: 'UPLOAD_TO_NEXUS', defaultValue: false, description: 'Upload artifacts to Nexus')
        booleanParam(name: 'PUSH_GIT_CHANGES', defaultValue: false, description: 'Push changes and create tag')
        
        // Integration controls
        booleanParam(name: 'ENABLE_GITLAB_STATUS', defaultValue: false, description: 'Update GitLab commit status')
        booleanParam(name: 'ENABLE_TELEGRAM', defaultValue: false, description: 'Send Telegram notifications')
    }

    environment {
        // Nexus configuration
        NEXUS_VERSION = "nexus3"
        NEXUS_PROTOCOL = "http"
        NEXUS_URL = "nexus:8081"
        NEXUS_REPO = "my-artifacts"
        NEXUS_CREDENTIALS_ID = "bb41509b-d0cc-4f65-94a4-755c22441930"
        GROUP_ID = "WmcA"
        ARTIFACT_ID = "flask-app"
        
        // Git configuration for pushing changes
        GIT_CREDENTIALS_ID = "gitlab-credentials"
        
        // Timestamp to use throughout the pipeline - in format yearmonthday hour minutes seconds
        TIMESTAMP = sh(script: 'date +%Y%m%d%H%M%S', returnStdout: true).trim()
    }

    stages {
        stage('Load Utilities') {
            steps {
                script {
                    // Load utility functions from the includes directory
                    utils = load "includes/cicdUtils.groovy"
                }
            }
        }
        
        stage('Checkout') {
            steps {
                checkout scm
                scmSkip(deleteBuild: true, skipPattern:'.*\\[ci skip\\].*')
            }
        }

        stage('Load Configuration') {
            steps {
                script {
                    echo "Loading configuration from jenkins-config.yml if available..."
                    
                    // Initialize global variables for stage control
                    env.DO_RUN_TESTS = params.RUN_TESTS.toString()
                    env.DO_RUN_RUFF_CHECK = params.RUN_RUFF_CHECK.toString()
                    env.DO_RUN_BANDIT_CHECK = params.RUN_BANDIT_CHECK.toString()
                    env.DO_UPDATE_VERSION = params.UPDATE_VERSION.toString()
                    env.DO_BUILD_EXECUTABLE = params.BUILD_EXECUTABLE.toString()
                    env.DO_ARCHIVE_EXECUTABLE = params.ARCHIVE_EXECUTABLE.toString()
                    env.DO_UPLOAD_TO_NEXUS = params.UPLOAD_TO_NEXUS.toString()
                    env.DO_PUSH_GIT_CHANGES = params.PUSH_GIT_CHANGES.toString()
                    env.DO_ENABLE_GITLAB_STATUS = params.ENABLE_GITLAB_STATUS.toString()
                    env.DO_ENABLE_TELEGRAM = params.ENABLE_TELEGRAM.toString()
                    
                    // Try to load the configuration file
                    try {
                        if (fileExists('jenkins-config.yml')) {
                            echo "Found jenkins-config.yml file, loading configuration..."
                            def config = readYaml(file: 'jenkins-config.yml')
                            echo "Config loaded: ${config}"
                            
                            // Override global variables with values from config file
                            if (config.runTests != null) env.DO_RUN_TESTS = config.runTests.toString()
                            if (config.runRuffCheck != null) env.DO_RUN_RUFF_CHECK = config.runRuffCheck.toString()
                            if (config.runBanditCheck != null) env.DO_RUN_BANDIT_CHECK = config.runBanditCheck.toString()
                            if (config.updateVersion != null) env.DO_UPDATE_VERSION = config.updateVersion.toString()
                            if (config.buildExecutable != null) env.DO_BUILD_EXECUTABLE = config.buildExecutable.toString()
                            if (config.archiveExecutable != null) env.DO_ARCHIVE_EXECUTABLE = config.archiveExecutable.toString()
                            if (config.uploadToNexus != null) env.DO_UPLOAD_TO_NEXUS = config.uploadToNexus.toString()
                            if (config.pushGitChanges != null) env.DO_PUSH_GIT_CHANGES = config.pushGitChanges.toString()
                            if (config.enableGitlabStatus != null) env.DO_ENABLE_GITLAB_STATUS = config.enableGitlabStatus.toString()
                            if (config.enableTelegram != null) env.DO_ENABLE_TELEGRAM = config.enableTelegram.toString()
                            
                            echo "Configuration values set from config file"
                        } else {
                            echo "No jenkins-config.yml file found, using parameter values"
                        }
                    } catch (Exception e) {
                        echo "Error loading config file: ${e.getMessage()}"
                        echo "Using parameter values instead"
                    }
                }
            }
        }
        
        stage('Pipeline Start') {
            steps {
                script {
                    // Update GitLab status if enabled
                    utils.updateGitLabStatus('pipeline', 'running', env.DO_ENABLE_GITLAB_STATUS.toBoolean())
                    
                    // Send notification
                    utils.notify("üöÄ Pipeline started for ${env.JOB_NAME} #${env.BUILD_NUMBER} at ${TIMESTAMP}", 
                            env.DO_ENABLE_TELEGRAM.toBoolean())
                    
                    // Print selected stages for clarity
                    echo "Running with the following configuration:"
                    echo "Tests: ${DO_RUN_TESTS}"
                    echo "Ruff Check: ${DO_RUN_RUFF_CHECK}"
                    echo "Bandit Check: ${DO_RUN_BANDIT_CHECK}"
                    echo "Update Version: ${DO_UPDATE_VERSION}"
                    echo "Build Executable: ${DO_BUILD_EXECUTABLE}"
                    echo "Archive Executable: ${DO_ARCHIVE_EXECUTABLE}"
                    echo "Upload to Nexus: ${DO_UPLOAD_TO_NEXUS}"
                    echo "Push Git Changes: ${DO_PUSH_GIT_CHANGES}"
                    echo "GitLab Status Updates: ${DO_ENABLE_GITLAB_STATUS}"
                    echo "Telegram Notifications: ${DO_ENABLE_TELEGRAM}"
                }
            }
        }
        
        stage('Run Tests') {
            when {
                expression { 
                    return env.DO_RUN_TESTS == 'true' 
                }
            }
            steps {
                script {
                    utils.runStage('tests', 'Running tests with pytest... üß™',
                            env.DO_ENABLE_GITLAB_STATUS.toBoolean(),
                            env.DO_ENABLE_TELEGRAM.toBoolean()) {
                        sh '''
                        . /app/venv/bin/activate
                        python -m pytest srcs/tests --maxfail=1 --disable-warnings -v
                        '''
                    }
                }
            }
        }

        stage('Code Quality Check - Ruff') {
            when {
                expression { 
                    return env.DO_RUN_RUFF_CHECK == 'true' 
                }
            }
            steps {
                script {
                    utils.runStage('ruff-check', 'Running Ruff code quality check... üîç',
                            env.DO_ENABLE_GITLAB_STATUS.toBoolean(),
                            env.DO_ENABLE_TELEGRAM.toBoolean()) {
                        sh '''
                        . /app/venv/bin/activate
                        python -m ruff check . --select all
                        '''
                    }
                }
            }
        }

        stage('Security Check - Bandit') {
            when {
                expression { 
                    return env.DO_RUN_BANDIT_CHECK == 'true' 
                }
            }
            steps {
                script {
                    utils.runStage('bandit', 'Running Bandit security check... üîí',
                            env.DO_ENABLE_GITLAB_STATUS.toBoolean(),
                            env.DO_ENABLE_TELEGRAM.toBoolean()) {
                        sh '''
                        . /app/venv/bin/activate
                        python -m bandit -r . -ll -iii
                        '''
                    }
                }
            }
        }

        stage('Update Version Information') {
            when {
                expression { 
                    return env.DO_UPDATE_VERSION == 'true' 
                }
            }
            steps {
                script {
                    utils.runStage('version-update', 'Updating version information... üìù',
                            env.DO_ENABLE_GITLAB_STATUS.toBoolean(),
                            env.DO_ENABLE_TELEGRAM.toBoolean()) {
                        // Update version.py with the timestamp
                        sh "sed -i \"s/\\\${PLACEHOLDER_VERSION}/${env.TIMESTAMP}/g\" srcs/main/version.py"
                        
                        // Verify version.py was updated correctly
                        sh "cat srcs/main/version.py"
                        
                        // Also update version.info file to keep it in sync
                        sh "echo ${env.TIMESTAMP} > version.info"
                    }
                }
            }
        }

        stage('Build Executable') {
            when {
                expression { 
                    return env.DO_BUILD_EXECUTABLE == 'true' 
                }
            }
            steps {
                script {
                    utils.runStage('build', 'Building executable using PyInstaller... üîß',
                            env.DO_ENABLE_GITLAB_STATUS.toBoolean(),
                            env.DO_ENABLE_TELEGRAM.toBoolean()) {
                        // Run PyInstaller directly using the binary instead of the module
                        sh '''
                        . /app/venv/bin/activate
                        /app/venv/bin/pyinstaller --onefile srcs/main/app.py --name flask-app
                        '''
                    }
                }
            }
        }

        stage('Archive Executable') {
            when {
                expression {
                    return env.DO_ARCHIVE_EXECUTABLE == 'true' && env.DO_BUILD_EXECUTABLE == 'true' 
                }
            }
            steps {
                script {
                    utils.runStage('archive', 'Archiving the built executable... üì¶',
                            env.DO_ENABLE_GITLAB_STATUS.toBoolean(),
                            env.DO_ENABLE_TELEGRAM.toBoolean()) {
                        archiveArtifacts artifacts: 'dist/flask-app', fingerprint: true
                    }
                }
            }
        }

        stage('Upload to Nexus') {
            when {
                expression { 
                    return env.DO_UPLOAD_TO_NEXUS == 'true' && env.DO_BUILD_EXECUTABLE == 'true' 
                }
            }
            steps {
                script {
                    utils.runStage('nexus-upload', 'Uploading artifacts to Nexus... üöÄ',
                            env.DO_ENABLE_GITLAB_STATUS.toBoolean(),
                            env.DO_ENABLE_TELEGRAM.toBoolean()) {
                        // Upload with "latest" tag
                        nexusArtifactUploader(
                            nexusVersion: env.NEXUS_VERSION,
                            protocol: env.NEXUS_PROTOCOL,
                            nexusUrl: env.NEXUS_URL,
                            groupId: env.GROUP_ID,
                            version: 'latest',
                            repository: env.NEXUS_REPO,
                            credentialsId: env.NEXUS_CREDENTIALS_ID,
                            artifacts: [
                                [
                                    artifactId: env.ARTIFACT_ID,
                                    type: 'bin',
                                    file: 'dist/flask-app',
                                    classifier: ''
                                ]
                            ]
                        )
                        
                        // Upload with timestamp tag
                        nexusArtifactUploader(
                            nexusVersion: env.NEXUS_VERSION,
                            protocol: env.NEXUS_PROTOCOL,
                            nexusUrl: env.NEXUS_URL,
                            groupId: env.GROUP_ID,
                            version: env.TIMESTAMP,
                            repository: env.NEXUS_REPO,
                            credentialsId: env.NEXUS_CREDENTIALS_ID,
                            artifacts: [
                                [
                                    artifactId: env.ARTIFACT_ID,
                                    type: 'bin',
                                    file: 'dist/flask-app',
                                    classifier: ''
                                ]
                            ]
                        )
                    }
                }
            }
        }

        stage('Push Changes & Create Tag') {
            when {
                expression { 
                    return env.DO_PUSH_GIT_CHANGES == 'true' && env.DO_UPDATE_VERSION == 'true' 
                }
            }
            steps {
                script {
                    utils.runStage('git-push', 'Updating repositories and tagging release... üì§',
                            env.DO_ENABLE_GITLAB_STATUS.toBoolean(),
                            env.DO_ENABLE_TELEGRAM.toBoolean()) {
                        withCredentials([usernamePassword(credentialsId: env.GIT_CREDENTIALS_ID, 
                                                         usernameVariable: 'GIT_USERNAME', 
                                                         passwordVariable: 'GIT_PASSWORD')]) {
                            // Set up Git configuration
                            sh '''
                                git config user.email "claudio0017.work@gmail.com"
                                git config user.name "crea"
                            '''
                            
                            // Helper function to build Git URL with credentials
                            def gitRepoUrl = 'http://${GIT_USERNAME}:${GIT_PASSWORD}@gitlab/pipeline-project-group/pipeline-project.git'
                            
                            // Update version info and commit
                            utils.updateVersionInfo(gitRepoUrl, env.TIMESTAMP, env.GIT_BRANCH)
                            
                            // Create and push tag (after main branch is updated)
                            utils.createReleaseTag(gitRepoUrl, env.TIMESTAMP)
                            
                            // Notify about successful operations
                            utils.notify("Jenkins: Version ${env.TIMESTAMP} pushed to current branch and main. Tag created successfully.",
                                      env.DO_ENABLE_TELEGRAM.toBoolean())
                        }
                    }
                }
            }
        }
    }
    
    post {
        success {
            script {
                utils.updateGitLabStatus('pipeline', 'success', env.DO_ENABLE_GITLAB_STATUS.toBoolean())
                utils.notify("üéâ Pipeline succeeded for ${env.JOB_NAME} #${env.BUILD_NUMBER}! All stages completed successfully.",
                           env.DO_ENABLE_TELEGRAM.toBoolean())
            }
        }
        failure {
            script {
                utils.updateGitLabStatus('pipeline', 'failed', env.DO_ENABLE_GITLAB_STATUS.toBoolean())
                utils.notify("‚ùå Pipeline failed for ${env.JOB_NAME} #${env.BUILD_NUMBER}. Check Jenkins for details.",
                           env.DO_ENABLE_TELEGRAM.toBoolean())
            }
        }
    }
}